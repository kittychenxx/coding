面经题

## html知识

- [x] 1 html语义化
- [x] 2 canvas svg
- [ ] 3 本地存储(localStorage、sessionStorage、cookie的理解)
- [ ] 4 video和audio的使用
- [ ] 5 应用缓存(cache manifest)
- [x] 6 dpr

### 1 HTML语义化是什么？

语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。

​	为什么要语义化？

- 有利于SEO，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重。
- 语义化的HTML在没有CSS的情况下也能呈现较好的内容结构与代码结构
- 方便其他设备的解析
- 便于团队开发和维护

### 2 canvas svg

##### canvas

* 功能：`canvas`会创建一个固定大小的画布，会公开一个或多个**渲染上下文**(画笔)，使用**渲染上下文**来绘制和处理要展示的内容。

- 样式：看起来和`<img>`一样，但是没有`src、alt`属性，只有`height、width`，默认样式`height=150px`,`width=300px`，不建议设置`css`属性，设置的宽高比例与原来不一致的时候，会出现扭曲
- 兼容性问题：IE9之前的IE浏览器都不支持`<canvas>`，不支持的情况会显示替代的内容，支持的浏览器会忽略替代的内容
- 结束标签`</canvas>`不可以省略，否则文档的其余部分会被当做替代内容显示出来
- 使用时：检测支持性
- 绘制矩形：仅支持一种原生图形绘制：矩形
  - `filRect(x,y,width,height)`：绘制一个填充的矩形
  - `strokeRect(x,y,width,height)`：绘制一个矩形的边框
  - `clearRect(x,y,width,height)`：清楚指定的矩形区域，然后这块区域会变成完全透明
    - x,y：指的是矩形左上角的坐标
    - width,height：指的是矩形的宽高
- 绘制路径（线段、三角形边框、填充三角形）、绘制圆弧、贝尔赛曲线

补充：https://www.runoob.com/w3cnote/html5-canvas-intro.html



#### svg

* 定义：SVG 是使用 XML 来描述二维图形和绘图程序的语言。是可伸缩矢量图形，用来定义用于基于矢量的图像

* 优势：
  - 矢量图形，画质优秀，不会失真	1  
  - 图像中的文本可选，同时可以搜索（适合制作地图）
  - 纯粹的XML，开放的标准，可与java一起运行
  - 与 Flash 相比，SVG 最大的优势是与其他标准（比如 XSL 和 DOM）相兼容。而 Flash 则是未开源的私有技术

* 兼容性：Internet Explorer9，火狐，谷歌Chrome，Opera和Safari都支持SVG。

  IE8和早期版本都需要一个插件 - 如Adobe SVG浏览器，这是免费提供的。

* 创建：可以用任何文本编辑器创建，往往与绘图程序一起使用，例如[lnkscape](https://inkscape.org/)（墨迹）

### 6 dpr

![1587375097736](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1587375097736.png)



## CSS

- [x] 1 flex布局
- [x] 2 页面布局
- [x] 3 移动端1px
- [x] 4 盒子模型
- [x] 5 CSS使用方式
- [x] 6 伪类与伪元素
- [x] 7 优先级
- [x] 8 常见样式命名
- [x] 9 定位方式
- [x] 10 border属性画图形
- [x] 11 BFC
- [x] 12 零散点（有道云笔记）

### 1 flex布局

#### [了解flex布局](https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

又称为弹性布局，给盒模型提供很大的灵活度。//注意://设置flex布局后，float、clear、vertical-align都会失效

任意的容器都可以使用flex布局，即display:flex

行内元素也可以使用，即display:inline-flex

如果是webkit内核浏览器，必须加上-webkit前缀，即display：-webkit-flex，（display：flex 这个也要加上，不然会报错)

**基本概念**

flex布局的元素称为容器，容器里的元素为flex item

**容器 *默认有两个轴，主轴为main axis，开始处为 main start，结尾为main end ；交叉轴为cross axis，同理有cross start cross end

**子项目**的尺寸属性 ，简单解释为宽（横向）main-size，高（纵向）cross size

**容器属性介绍**

flex-direction：子项目的排列方向，横排（row 、row-reverse），纵排（column、column-reverse），默认是row，横向排列即水平排列

正序是指从左到右，从上到下；倒序（reverse）则反过来

fiex-wrap：如何换行，默认子项目都在一条轴线上，nowrap（不换行）|wrap（换行后，第一行在上方）|wrap-reverse（换行后，原本应该为第二行的为第一行）

**flex-float：**排列方向和换行方式的简写，即可flex-float：row nowrap;

justify-content：主轴上的对齐方式，flex-start|flex-end|center|space-between|space-around (右对齐，左对齐，居中，两端对齐，项目两侧的间隔相等)

align-items：交叉轴的对齐方式，和主轴的对齐方式前三个一样，还有strentch和baseline，strentch是默认值，同时如果子项目没有高度设置的话，默认的高度是占满整个容器的高度，baseline是有一条基准线，项目的第一行要与基准线标齐

align-content：定义了多根轴线的情况的对齐方式，只有一根轴线的时候，属性不起作用，属性值集合了justify-content的属性值 flex-start|flex-end|center|space-between|space-around 再加上 strentch ，默认是**strentch**，**轴线占满整个交叉轴**

**项目属性介绍**

**flex：**是flex-grow（项目放大比例，默认不放大，即使有剩余空间），flex-shrink（缩小比例，默认为1，空间不足时项目会缩小），flex-basis（在分配多余空间之前，项目占据的主轴空间（main size））的简写，默认值为 flex: 0 1 auto,后两个属性可选

有两个快捷键，auto（1 1 auto），none（0 0 auto）

align-self：允许单个项目有不同的对齐方式，可以覆盖align-items，默认为auto，继承父元素，如果没有父元素则默认为stretch

应用flex布局的几种格式[系统了解栅格系统](https://magic-akari.github.io/solved-by-flexbox/demos/grids/)

#### **flex的应用场景**

实现垂直居中的效果

```
display: flex;
justify-content:center;
align-items:center;
```

响应式布局：可以为不同终端的用户提供更加舒适的界面和更好的用户体验

```
.father{
	display:flex;
}
.child{
	flex:1;
}
```

### 2 页面布局

#### 行布局

margin：0 auto；上下为0，左右居中

width：100% 页面自适应

![1566292033179](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1566292033179.png)

margin-top 和margin-left对应要减去本身元素的一半高宽

#### 列布局

#### 圣杯布局

说明：

三列布局，中间宽度自适应，两边定宽；

中间栏要在浏览器中优先展示渲染；

允许任意列的高度最高；

用最简单的CSS、最少的HACK语句（条件注释语句）

1. 可以采用全部元素float：left
2. 中间的部分都采用float：left，需要清除浮动，可以采用之前的三种清除浮动的方法

#### 双飞翼布局

-经淘宝UED的工程师针对圣杯布局改良后得出双飞翼布
-去掉相对布局,只需要**浮动和负边距**

好处：

1. 主要内容先加载的优化
2. 兼容目前所有的主流浏览器，包括IE6
3. 实现不同的布局方式，调整css属性即可实现

#### 布局经验总结

1.布局的开始要将所有元素的padding和margin置零

2.**页头页尾要是有float：left才能使得元素不按照标准流放置**

3.用margin-left和margin-right调整元素的外边距已达到预想效果

4.首先float：left；如若要是元素置于最右侧则使用margin-left：自身的宽的负数，同时如若要是元素置于最左侧则使用margin-left：-100%

### 3 移动端1px问题

1. 编写样式，达到1px效果

```stylus
border-1px($color) //会传入color参数 
  position: relative
  &:after // 加个伪类
    display: block
    position: absolute
    left: 0
    bottom: 0
    width: 100%
    border-top: 1px solid $color;// 没有逗号会报错
    content: ' '
```

编写完，需要在`App.vue`文件`style`便签`import`，要用`@import`，是`stylus`的特殊语法，可以访问任何路径下的`styl`文件

2. 实现缩放

```stylus
@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5)  // dpr的最小缩放比为1.5设备
  .border-1px // 将1px这个样式定义为全局下的样式，所有文件都可以使用它
    &::after
      -webkit-transform: scaleY(0.7) // 加webkit是为了浏览器的兼容性
      transform: scaleY(0.7)

@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) //dpr=2的设备
  .border-1px
    &::after
      -webkit-transform: scaleY(0.5)
      transform: scaleY(0.5)
```



### 4 盒子模型

**注意**：

1. **display属性**：内联元素和inline元素的width和height无效，水平的padding和margin有效，垂直无效；块级元素和block各属性都有效
2. margin属性：
   - 垂直方向上的两个div都有设置margin的话，会合并等于较大的数
   - 默认的，块级元素本身具有margin设置，需要先margin：0
   - auto代表水平居中，由浏览器计算外边距

#### 标准盒子

标准盒子的宽度和高度是不包括内边距和边框的，即只计算内容的宽度和高度，所以相应的box-sizing：content-box

#### IE**盒子**

IE盒子的宽度和高度是包括边框和内边距的，box-sizing：border-box；IE盒子模型在IE6就不存在了

#### JS设置、获取盒模型的宽高

https://www.cnblogs.com/lemonmonster/p/9405838.html

```
1. dom.style.width/height //指能获取内联样式的宽高
2. dom.currentStyle.width/height //只适合IE
3. window.getComputedStyle(dom).width/height //可以获得当前元素的所有使用的CSS属性，并且兼容性很好
4. dom.getBoundingCLientRect().wdith/height //获取某个元素相对视窗的位置的集合，有top，left，right，height，width，x，y..兼容性很好
/////
   rectObject = dom.getBoundingClientRect()

　　rectObject.top：元素上边到视窗上边的距离;

　　rectObject.right：元素右边到视窗左边的距离;

　　rectObject.bottom：元素下边到视窗上边的距离;

　　rectObject.left：元素左边到视窗左边的距离;

　　rectObject.width：元素宽度;

　　rectObject.height：元素高度;

　　rectObject.x：元素内容与视口的水平距离;

　　rectObject.y：元素内容与视口的垂直距离;

```

#### 盒模型边距重叠

子元素有margin，但是父元素没有border或者padding，子元素会层层越级，把自己的外边距当做祖先元素的外边距，从而造成了外边距重叠

**解决方法**：

	1. 设置父元素的padding或者border
 	2. 使用BFC

**BFC解决外边距重叠的方法**

1.BFC的基本概念：block-formatting-contexts**块格式化上下文**

可以理解成布局内的一个迷你布局，里面的东西不会伸出来，也不会影响盒子外面的布局

2.原理（渲染规则）：

bfc内元素的垂直方向的边距发生重叠；选取最大的margin

bfc的区域不会与浮动元素的box重叠；

bfc在页面是个**独立的容器**（外面的元素不会影响里面的元素，相反同理）；

**计算BFC高度时浮动元素不会参与计算**；

3.如何创建bfc：

overflow不为visible;

float:不为none;

position为absolute;

display: inline-block table-cell等等

4.BFC使用场景

清除子元素浮动造成的父元素高度为0：给父元素加BFC；

解决外边距重叠问题：把每一个元素加BFC的父元素

左侧浮动，右侧自适应不畸形，条件左右高度不一：给右侧设置为BFC

解决外边距塌陷的问题



### 5 CSS使用方式

**在html内**：

- 行内样式：便签内设置style样式
- 内部样式：在head标签内的style标签

**CSS样式文件与Html文件分离**

- 外部样式：在head标签中link标签引用，link要放在head之间
- 导入式：import '外部css样式'，写在style标签最开始

**优先级：**行内样式》内部样式》外部样式 （遵循就近原则）

**加载时间：**

- 行内样式、内部样式、外部样式同时和html加载	
- 导入样式，在页面加载完时，再开始加载



### [6 伪类与伪元素](https://www.jianshu.com/p/9086114e07d4)

在css3标准里伪类用单冒号，伪元素类用双冒号，但是浏览器还是支持伪元素用单冒号的写法

例如 `:before ，:after，:first-line，:first-letter`

#### **伪类**：为元素的某状态设置样式，通过添加类来实现效果

**主要的状态伪类**：

focus：键盘输入焦点，first-child：元素的第一个子元素，link：未访问状态，visited：访问状态，hover：悬停状态，active：激活状态

**hover必须在link和visited后面才有效**

**active必须在hover后面才有效**

他们的顺序：:link > :visited > :hover > :active

**结构伪类**：

主要是利用dom树对元素进行过滤，通过文档结构像某些选择器添加样式，可以适当的减少class和id属性的定义，是文档结构更加简洁

```
:first-child | :last-child | :nth-child() | :nth-last-child() //选择子元素的方式
:nth-of-type() | :nth-last-of-type() //选择指定的元素的方式
：only-child //选择的是其父元素唯一的子元素
：only-of-type //选择的是其父元素唯一相同类型的子元素
：enpty //选择内容为空的元素
```

#### **伪元素**：伪元素选择html中不存在的元素

```
:first-letter //选择文本第一个字母
:first-line //选择第一行
:before //选择在元素前面添加内容
:after //选择在元素后面添加内容
```

一般在写清除浮动的样式的时候，:after的写法比 ::after的写法更加向后兼容

### 7 CSS优先级

1、!important声明高 `p{color:red !important}`

2、CSS使用方法优先级：行内样式 > 内部样式  > 外部样式

注意`link链入外部样式和style内部样式优先级，取决于先后顺序`

3、样式表中优先级：id选择器>class选择器>标签选择器>通配符

### 8 常见样式命名

**页面结构**

页面主体main

内容content/container

容器container

导航nav

侧栏sidebar

栏目column

页面外围控制wrapper

**导航**

边导航sidebar

右导航rightsidebar

左导航leftsidebar

摘要summary

**功能**

标志logo

广告banner

登陆login

登陆条loginbar

注册register

功能区shop

### 9 定位方式：标准流、float、position

#### **float**：

```
float: left | right |none |inherit
```

left：左浮动；right：右浮动；none：不设置浮动；inherit：如果父元素有设置浮动的话，继承父元素的浮动设置

**浮动带来的副作用**：浮动使元素脱离页面的文档流，后面的元素忽视了前面元素的存在

会有以下三种情况：

1. 块级元素，会钻到浮动元素的下面，被浮动元素覆盖
2. 浮动元素和文字，文字不会包围浮动元素，而是被浮动元素遮住
3. 浮动元素的父元素高度坍塌

**清除浮动的方法：**

1. clear样式通过clear属性清除内部和外部浮动

```stylus
.clear{
	clear both
	height 0
	width 0
  overflow hidden
}
```

2. 给父元素设置overflow为hidden或者auto并zoom:1使用，主要就是让父元素里浮动的子元素隐藏，回到文档标准流

```stylus
.father
  overflow auto |hidden
  zoom 1 // 处理兼容性问题？？

```

3. 使用伪元素 :after，给父元素高度 (该伪元素用单冒号，更加向后兼容)，推荐此方法，更优化，给DOM节点增加元素

```stylus
 //或者理解为在父元素后面加一个没有任何内容的块级元素
 .clearfix
   display inline-block
   &:after
     display block
     content ''
     height 0
     line-height 0
     clear both
     visiablity hidden //新增的元素不让它显示,但是它是占用空间的，display：none，也是不显示，但会让出空间
```

#### **position**：

通过设置TRBL来定位在页面中的位置，可选的属性值：static、relative、absolute、fixed、inherit 【TBRL是指top、bottom、right、left】

**1. ralative**：不脱离文档流，移动的范围是整个网页，通过TRBL定位，同时为子元素划分作用域

CSS中的写法是：position:relative;  他的意思是相对定位，他是参照父级的原始点为原始点，无父级则以BODY的原始点为原始点，配合TRBL进行定位，当父级内有padding等CSS属性时，当前级的原始点则参照父级内容区的原始点进行定位。

![img](C:\Users\陈晓琪\Desktop\notes\1581238510693-4d745572-b64e-4410-b3b5-6be15804828c.gif)



**2. absolute**：脱离文档流，移动的范围是整个网页，通过TRBL定位，同时也为子元素划分作用域

CSS中的写法是：position:absolute; 他的意思是绝对定位，他是参照浏览器的左上角，配合TOP、RIGHT、BOTTOM、LEFT(下面简称TRBL)进行定位，在没有设定TRBL，默认依据父级的做标原始点为原始点。如果设定TRBL并且父级没有设定position属性，那么当前的absolute则以浏览器左上角为原始点进行定位，位置将由TRBL决定。

![img](C:\Users\陈晓琪\Desktop\notes\1581238503096-e4a8bbd3-1cfd-4922-88b9-373efea9c111.gif)

对比：如果absolute的父级元素有设置positon为relative的话，效果就和relative一样；如果祖先元素都没有设置positon的话就以浏览器左上角为定位参照点

**3. fixd：**脱离文档流，移动的范围是整个显示屏窗口，通过TRBL定位，同时也为子元素划分作用域

**4. inherit：**继承父元素的定位

**5. static**：文档流当前的位置

#### **z-index**：

css层级关系由z-index决定，数字大的显示在上层，越接近观察者页面被解析的时候，越后解析的元素的值越大，优先级越高

1.分层工具（设置元素的叠加顺序）、只对有定位的元素才有效

2.属性值大的会覆盖小的元素

3.如果父元素的z-index大于相邻的元素的值，则子元素也相应的大于相邻的元素，可以遮盖相邻元素

4.z-index为auto的元素不参与层级比较

5.为负值的元素会被普通流的元素覆盖

### 10  border属性画气泡对话框

**border**，有三个相关的属性值,还可以选择方向border-top..等

```
border: border-width |border-style |border-color
```

border-width

```
border-width:thin |medium |thick |长度值
```

border-color

```
border-color:颜色|tranparent
```

border-style

```
border-style:solid | double| dotted |dashed |...
```



学习文章：[张鑫旭老师的CSS border三角、圆角图形生成技术简介]([https://www.zhangxinxu.com/wordpress/2010/05/css-border%e4%b8%89%e8%a7%92%e3%80%81%e5%9c%86%e8%a7%92%e5%9b%be%e5%bd%a2%e7%94%9f%e6%88%90%e6%8a%80%e6%9c%af%e7%ae%80%e4%bb%8b/](https://www.zhangxinxu.com/wordpress/2010/05/css-border三角、圆角图形生成技术简介/))

学习文章：https://mp.weixin.qq.com/s?__biz=MjM5NTM1NDcyOQ==&mid=404124362&idx=1&sn=ffcd61e517ca0fb688a8397bde7f5d4d&scene=0#wechat_redirect

1. 利用伪元素实现三角

```html
  <style>
    .test-div{
        position: relative;  /*日常相对定位*/
        width:150px;
        height: 36px;
        border:black 1px solid;
        border-radius:5px;
        background: rgba(245,245,245,1)    }
    .test-div:before,.test-div:after{
        content: "";  /*:before和:after必带技能，重要性为满5颗星*/
        display: block;
        position: absolute;  /*日常绝对定位*/
        top:8px;
        width: 0;
        height: 0;
        border:6px red solid; //使用红色是为了效果明显
    }
  </style>
  <div class="test-div"></div>
```

![1587262732468](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1587262732468.png)

`.test-div:after`和`.test-div:before`是利用层叠实现的对话框前面的小三角（需要把上面边设置为透明，修改伪元素的border:6px transparent solid; 

```css
 .test-div:before{
        left:-11px;
        //border-right-color: rgba(245,245,245,1);
        z-index:1    } /* 优先显示before */
     .test-div:after{
        left:-12px;
        //border-right-color: rgba(0,0,0,1);
        z-index: 0    } /*在before的下一层*/
```

![1587266447857](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1587266447857.png)

还原原来的代码，可以看到气泡对话框的效果

![1587262778178](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1587262778178.png)

2. 纯css实现圆角

```html
<div class="box">
    <div class="top"></div>
    <div class="center">我是一只小小鸟、小小鸟！</div>
    <div class="bot"></div>
</div>
<style>
    .box{width:500px;}
    .top{border-bottom:3px solid;border-top:3px solid; border-top-color:#000000; border-bottom-color:#cc0000; border-left:3px dotted transparent;
    border-right:3px dotted transparent;}
    .center{padding:10px 20px; color:white; font-size:14px; background:#cc0000;}
    .bot{border-top:3px solid; border-top-color:#cc0000; border-bottom-color:#cccccc; border-left:3px dotted transparent;
    border-right:3px dotted transparent;}
</style>
```

对话框的盒子其实是被分成了三份，上下需要设置border相关属性来实现想要的效果，中间是文字

圆角的实现是利用了一个长方形分成下面这样，将上边框、左边框、右边框的颜色设置为transparent，其实下面的`border-top-color`可以删去，不会有影响，也没给它设置长度，还有值得注意一点是dotted、solid，两个的样式的差别都不大，我是看不出来，感兴趣的可以试试

![1587264036909](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1587264036909.png)

```css
		.top{border-bottom:3px solid;border-top:3px solid; border-top-color:#000000; border-bottom-color:#f3d3d3; border-left:3px dotted red;border-right:3px dotted red;}
    .center{padding:10px 20px; color:white; font-size:14px; background:#cc0000;}
    .bot{border-top:3px solid; border-top-color:#cc0000; border-bottom-color:#cccccc; border-left:3px dotted transparent;
    border-right:3px dotted transparent;}
</style>
```

![1587266216116](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1587266216116.png)



### 11 BFC



参考文章：https://juejin.im/entry/59c3713a518825396f4f6969

https://www.jianshu.com/p/e2deb1529d46

**含义：**就是对设置为BFC（Block Formatting Contexts）的内部元素当做块级元素处理，同时设置我BFC的元素也要作为块元素进行处理，其他与BFC同级的元素也要作为块元素处理，BFC和同级元素不会发生作用，即重叠的问题

#### **建立BFC的做法**

1. overflow不为visible
2. float不为none
3. display为inline-block | table-caption |table-cell
4. position不为static或者是relative

普通的文档流：

1. 浮动的元素不计入父级元素的高度
2. 浮动的元素会遮挡正常文档流的元素（涉及清除浮动问题）
3. margin值会传递给父元素
4. 两个相邻的元素上下的margin值会重叠（margin重叠问题）

#### BFC的布局规则

1. 父元素的高度包括浮动元素的高度
2. 浮动元素不会遮挡正常文档流的元素
3. 子元素的margin不会越级传递
4. 两个上下相邻的元素的margin不会重叠（各自放置BFC中 overflow：hidden；）





1 .根元素下的两个元素，垂直方向的margin会重叠，解析的时候会两个元素之间的距离为两个元素当中的最大的border

解决方法：将根元素下的两个元素放进BFC中，给包裹元素设置overflow：hidden；建立新的BFC，从而可以消除重叠

![1587543201930](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1587543201930.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<style type="text/css">
		div{
			overflow:hidden;
		}
		.item{
			width: 100px;
			height:100px;
			background-color: #ff0900;
			padding:10px;
			border: 1px solid black;
      margin:10px;
		}
	</style>
</head>
<body>

	<div>
		<p class="item">子</p>
	</div>
	<div>
		<p class="item">子</p>
	</div>
</body>
</html>
```

2. 水平排列时候的margin重叠

解决方法：元素设置display:inline-block;

![1587543156474](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1587543156474.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<style type="text/css">
		body{
			width: 100%;
			height: 200px;
			writing-mode:vertical-lr; // 设置块级元素前进的方向为从左端开始水平进行
		}
		div{
			width: 100px;
			height:100px;
			background-color: #ff0900;
			padding:10px;
			border: 1px solid black;
			margin: 10px;
			/*display: inline-block;*/
		}
	</style>
</head>
<body>
	<div></div>
	<div></div>
</body>
</html>
```

3.嵌套的元素，不仅外部有margin重叠，内部的全部元素和上方元素的margin会相互比较，选取最大的进行渲染

![1587544692991](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1587544692991.png)

![1587544813024](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1587544813024.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<style type="text/css">
		div{
			width: 200px;
			height: 200px;
			background: #322334;
			margin: 20px;
		}
		ul{
			width: 200px;
			height: 200px;
			background: #322334;
			margin: 10px;
			/*display: inline-block;*/ 
		}
		li{
			width: 50px;
			height: 50px;
			background-color: #ff0900;
			margin: 10px;
		}
	</style>
</head>
<body>
	<div></div>
	<ul>
		<li></li>
		<li></li>
	</ul>
</body>
</html>
```



解决方法：给ul添加display：inline-block；ul就为BFC，就解决内部和外部的margin重叠的问题了，如果ul本身有padding属性或者border属性的话，元素的margin会包括在父元素ul里，注意不会与父元素的padding重叠，相当于li是接着放在ul的padding边上。

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<style type="text/css">
		div{
			width: 200px;
			height: 200px;
			background: #322334;
			margin: 20px;
		}
		ul{
			width: 200px;
			height: 200px;
			background: #322334;
			margin: 10px;
			/*padding: 20px;*/
			border: 2px dashed blue;
			display: inline-block;
		}
		li{
			width: 50px;
			height: 50px;
			background-color: #ff0900;
			margin: 10px;
		}
	</style>
</head>
<body>
	<div></div>
	<ul>
		<li></li>
		<li></li>
	</ul>
</body>
</html>
```



4. 清除浮动

之前遇到过的子元素浮动，造成父元素的高度塌陷的问题，一样的处理方式，原理其实就是清除浮动让父元素成为BFC，注意，父元素的高度是包括浮动子元素的高度的。（不知道看到哪一篇介绍的，说不计入。实验出真知）

![1587545894715](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1587545894715.png)

![1587545928970](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1587545928970.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<style type="text/css">
		div{
			/*overflow: auto;*/
		}
		.item{
			width: 100px;
			height:100px;
			background-color: #ff0900;
			margin: 10px;
			float: left;
		}
	</style>
</head>
<body>

	<div>
		<p class="item"></p>
		<p class="item"></p>
	</div>
</body>
</html>
```



### 雪碧图

雪碧图即css sprites，是一种图像合成技术，在前端工作中为了减少图片资源的加载，可以把一些小的图标合并在一张图上，通过css的background-postion，调整图片的位置，从而选取到需要的图片，用雪碧图的好处是可以减少加载页面时太多的图片资源请求。

注意background-position：水平移动距离的负数，垂直移动距离的负数。可以理解位图片参照浏览器的左上角向左边移动，向上移动



****

## javaScript

- [x] JavaScript 事件循环机制
- [ ] 

#### 1 JavaScript 事件循环机制

​	JavaScript 事件循环机制分为浏览器和 Node 事件循环机制，两者的实现技术不一样，浏览器 Event Loop 是 HTML 中定义的规范，Node Event Loop 是由 libuv 库实现。这里主要讲的是浏览器部分。

​	Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。

- JS 调用栈

  JS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。

- 同步任务、异步任务

  JavaScript 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。

- Event Loop

  调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。

 





