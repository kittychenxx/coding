

## JS底层机制

- 浏览器渲染的时候(编译器)
    - 词法解析
    - AST抽象语法树
    - 构建能够执行的代码
    - 引 擎（v8）
    - 变量提升、作用域，闭包 、堆栈内存。
    - GO、VO、AO、EC、ECStack
### 堆、栈内存
- JS代码在浏览器运行的环境是栈内存(STACK)
	- 栈内存是代码执行的环境
	- 堆内存是存放各种属性方法
- EC(Excution Context) ->执行环境栈
	- 全局执行上下文 EC(G) ：要进栈执行
	- 函数中的代码都会在一个单独的私有的上下文中执行
	- 块级的执行上下文
- VO（变量对象)：在当前上下文中用来创建变量和和值的地方（每一个执行上下文中都会有自己的变量对象，私有上下文中的变量对象为AO）(1个html只有一个VO(G))，VO(G)不是GO，只是某种情况下的VO(G)的变量和全局的变量有关联（映射机制）
- GO 全局变量 是一块堆内存 存放浏览器的api属性和方法
- 创建函数：
	- 函数堆：
		
		1、把函数体中的代码当做字符串存放在函数堆里，"代码都是破字符串"，创建函数不执行，函数没有用
		
		2、函数也可以是对象，有自己的键值对
- 作用域 [[scope]]，函数创建的时候就定义函数的作用域->创建函数所在的上下文
  - 函数执行的目的：形成新的私有上下文，供代码执行（进栈执行） 
    <!-- AST语法解析  词法解析 -->
    1、创建一个值
    - 基本数据类型值是直接存储到栈内存中
    - 引用类型值是开辟一个堆内存，把代码串放入堆内存中
  
    2、创建一个变量
    3、让变量和值进行关联，所有的指针赋值都是指针的关联执行

### 数据类型7+2
- 基本类型是按值操作，引用类型是按地址操作

基本数据类型
```javascript
    null undefined number string boolean
    typeof 返回值类型
    typeof null == 'object' 
    typeof undefined === 'undefined'
    typeof 12 === 'number'
    typeof '123' === 'string'
    typeof true === 'boolean'
```

引用数据类型：
- 1、创建一个堆内存
- 2、把键值对存储到堆内存中
- 3、堆内存地址放到栈中提供变量使用
```javascript
    // object function 
    typeof [123] === 'object'
    typeof {} === 'object'
    typeof function(){} === 'function'
```

### 类型转化规则

1.对象==字符串  对象转换成字符串

```js
[10]=='10' //=>true
```

2.null==undefined（三个等号任何情况都不相等），但是和其它任何的值都不相等

```js
0==null //=>false
```

3.NaN不等于谁包括自己
**4.剩下的情况都是转换成数字做比较**

### 取反操作符的规则

对象转换为布尔类型都是true
其它类型只有0/NaN/null/undefined/‘’ 这五个值为false，其他值为true

### { } 特殊性

1.可以表示对象{}
2.代表代码块{块作用域}

```js
{} + 0 =>0 
0 +{} =>"0[object Object]"
{} + 0 + {} =>"[object Object]0[object Object]"
{}+0 == false;// NaN->false false==false //=>true
0+{} == true;//=>false 转换成数字比较
```

### let /var /const

- var声明会给全局对象GO增加一个对应的对应的属性
- 但是let /const 不会给全局增加变量
- let不能重复声明

```js
    let x =1;
    let x=2; //Uncaught SyntaxError: Identifier 'x' has already been declared
```
- let声明的变量可以更改指针的指向，可以重新赋值
- const声明的变量不允许更改指针的指向



### 4.24Day1/3作业

作业1：

```js
1. 
100 + true + 21.2 + null + undefined + "Tencent" + [] + null + 9 + false
//100+true=>100
//121.2
//121.2
//121+Number(undefined)=>NaN
//NaN+"Tencent"=>"NaNTencent"

//"NaNTencent"+Number(toString([]))
//"NaNTencent"+Number('')=>//"NaNTencent"

//"NaNTencentnull"
//"NaNTencentnull"+9=>"NaNTencentnull9"
//"NaNTencentnull9false"
```

考察：

```js
1.加号运算符的作用：加号运算、字符串拼接
2.
数字+除了字符串 =>都转化成数字
字符串+对象 =>都转换成字符串
数字+字符串 => 都转换成字符串
```

```js
2.
[]==false =>true
![]==false =>true

Number([]) == Number(false) =>true
Boolen([])==>true  ![] =>false  false==false =>true

```

```js
3.
{}+0?alert('ok'):alert('no');
0+{}?alert('ok'):alert('no');

{}可以指代码块或者一个对象
三元运算符 条件表达式？表达式1：表达式2
问号前面的位置是判断的条件，判断结果为布尔型

{}+0 =>0 no 代码计算+0，把{}当做代码块
0+{} =>将对象转换成boolean类型true，true=>1 =>0+1 =>1 ok

变形题 如果是==运算符
{}+0 == false;// NaN->false false==false //=>true
0+{} == true;//=>false
```

```js
4.下面代码输出的结果
let res = Number('12px');
if(res===12){
    alert(200);
}else if(res===NaN){
    alert(NaN);
}else if(typeof res==='number'){
    alert('number');
}else{
    alert('Invalid Number');
}

Number()方法，只要字符串里有非有效数字都是NaN，parseInt和parseFloat采用组合识别，才能识别字符串"12px"
=>res=NaN
=>typeof NaN =>"number"
=>alert('number')

```

```js
5.输出结果
var a={}, b='0', c=0;
a[b]='珠峰';
a[c]='培训';
console.log(a[b]);//培训
-----
var a={}, b=Symbol('1'), c=Symbol('1');
a[b]='珠峰';
a[c]='培训';
console.log(a[b]);//
-----
var a={}, b={n:'1'}, c={m:'2'};
a[b]='珠峰';
a[c]='培训';
console.log(a[b]);//珠峰(错)

//
b、c都是对象，对象存放这键值对，对象a的属性名必须是字符串
b.toSting =>[object Object]
c.toSting =>[object Object]
//=>console.log([object Object]) =>'培训'
```

```js
6.
var a = {n: 1};
var b = a;
a.x = a = {n: 2};
console.log(a.x);//=> undefined
console.log(b.x);//=> {n:2}

//
a.x={n:2}的优先级高于a={n:2}
代码执行
a.x新增{n:2}后，a又重新指向了对象{n:2}
b指向的对象{n:1,x:{n:2}}

7.下面代码输出的结果：
var x = [12, 23];
function fn(y) {
     y[0] = 100;
     y = [100];
     y[1] = 200;
     console.log(y);//=>[100,200]
}
fn(x);
console.log(x);//=>[100,23]

//
变量提升 var x,fn(y){}
代码执行 y[0]=100;=>全局的x=> [100,23]
				创建私有变量y指向对象[100,200]



8.
下面代码输出的结果：
let arr = [1, 2, 3, 4];
arr = arr.map(parseInt);
console.log(arr);

//题解知识点
/* 
 * 数组的迭代方法（遍历数组中的每一项做一些特殊的处理）
 *    forEach 遍历数组每一项（数组中有多少项，就会触发执行多少次回调函数，每一次把迭代的当前项和当前项的索引传递给回调函数）
 *    map 和forEach类似，只不过支持返回值，回调函数中的返回值会把当前迭代的这一项替换掉
 *    find 迭代数据每一项的时候，只要有一项在回调函数中返回TRUE则找到内容，后面不会在迭代了,返回的是找到的这一项
 *    filter 迭代每一项的时候，回调函数中所有返回TRUE的这一项获取到，以新数组返回（包含筛选出来的所有项）
 *    every 和some类似，但是回调函数都返回TRUE，整体才是TRUE
 *    some 验证数组中是否存在符合某个筛选条件的,只要有一个符合结果就是TRUE
 *    reduce 上一次回调函数中运算的结果会作为下一次处理的信息
 *    let total=arr.reduce(function(n,item){
 *       return n+item;
 *    },0);
 */
let arr = [1, 2, 3, 4];
// arr = arr.map(function (item, index) {
// 	// console.log(item, index);
// 	return item * index; //=>返回结果替换数组中当前迭代的这一项
// });
// console.log(arr);

arr = arr.map(parseInt);
console.log(arr);


// parseInt([value]): 把VALUE转换为数字，要求VALUE是字符串（不是字符串先默认转换为字符串），从字符串左边开始查找，找到有效数字字符转换为数字（遇到一个非有效的数字字符，则停止查找）
// parseInt([value],[radix])：首先[VALUE]是这个字符串，他是把个值看做[RADIX]这个进制，然后最后转换为10进制的数字
// radix省略或者为0，则radix默认按照10进行处理（特殊：字符串以 0x/oX 开头，radix默认按照16进行处理）
// radix不在2~36之间，最后结果都为NaN
// parseInt(1,0) =>1
// parseInt(2,1) =>NaN
// parseInt(3,2) =>NaN
// parseInt(4,3) =>NaN

// parseInt('2AF5', 16); //=>把'2AF5'当做16进制，最后转换为10进制
// // 5*1 + 15*16 + 10*16*16 + 2*16*16*16 = 10997
// '72.45'  -> 58.578125
// 2*1 + 7*8 + 4*(1/8) + 5*(1/(8*8))

// parseInt('231', 3);
// 3进制只能是 0~2  所以查找到3的时候，发现已经不是3进制的范畴了，则不再继续查找
// 把2当做3进制，最后转换为十进制
// 2*3^0 = 2

// parseInt('23461', 5);
// // '234' 看做 5进制，转换为10进制
// 4+3*5+2*5*5 = 69

```



### 数组的迭代方法

（遍历数组中的每一项做一些特殊的处理）

 *    forEach 遍历数组每一项（数组中有多少项，就会触发执行多少次回调函数，每一次把**迭代的当前项**和**当前项的索引**传递给回调函数）
 *    map 和forEach类似，只不过支持返回值，回调函数中的返回值会把当前迭代的这一项替换掉
 *    find 迭代数据每一项的时候，只要有一项在回调函数中返回TRUE则找到内容，后面不会在迭代了,返回的是找到的这一项
 *    filter 迭代每一项的时候，回调函数中所有返回TRUE的这一项获取到，以新数组返回（包含筛选出来的所有项）
 *    every 和some类似，返回的都是布尔值，但是验证数组必须整体都符合筛选条件，回调函数才返回TRUE
 *    some 验证数组中是否存在符合某个筛选条件的,只要有一个符合结果就是TRUE
 *    reduce 上一次回调函数中运算的结果会作为下一次处理的信息
```
     let total=arr.reduce(function(n,item){
				return n+item;
			},0);
```

### parseInt深入理解

- parseInt([value]): 把VALUE转换为数字，要求VALUE是字符串（不是字符串先默认转换为字符串），从字符串左边开始查找，找到有效数字字符转换为数字（遇到一个非有效的数字字符，则停止查找）
- parseInt([value],[radix])：首先[VALUE]是这个字符串，他是把个值看做[RADIX]这个进制，然后最后转换为10进制的数字
- radix省略或者为0，则radix默认按照10进行处理（特殊：字符串以 0x/oX 开头，radix默认按照16进行处理）
  **// radix不在2~36之间，最后结果都为NaN**

```js
parseInt(1,0) //=>NaN
```

- parseFloat没有第二个参数可以传，急事传了也没有影响

### 对象的属性名

- 普通对象的属性名只能是字符串，也可以是基本数据类型值
- Map对象的属性名可以是对象

```js
var a={}, b={n:'1'}, c={m:'2'};
a[b]='珠峰';
a[c]='培训';
console.log(a[b]);//珠峰(错)

//
b、c都是对象，对象存放这键值对，对象a的属性名必须是字符串,所以bc都会转换成字符串传入a
b.toSting =>[object Object]
c.toSting =>[object Object]
//=>console.log([object Object]) =>'培训'

```

普通对象的toString是调用Object.prototype.toString，是用来**检测对象的数据类型**，而不是转换成字符串，默认值为[object Object]


## 变量提升机制
**在当前上下文中（全局/块级/私有)，JS代码自上而下执行前，浏览器会提前处理一些事情，将当前上下文中带有VAR/FUNCTION关键字的提前进行声明或者定义**

- 带var的提前声明
- 带function的提前声明+定义

- 出现在判断体里的function，不管条件成不成立，只会function进行提前声明，不做赋值（新浏览器为了向前兼容ES3）
- 真实项目中建议采用函数表达式的方法创建函数，这样代码在还没有执行的时候，只是进行了提前的声明，没有进行赋值
- [老版本的浏览器ES3/5规范]
	1、判断体和函数体不存在块级上下文，上下文只有全局和私有
	2、无论判断体(function在判断体里）的条件是否成立，带function都提前声明+定义
- [最新的浏览器]
	1、遇到大括号中出现let/const/function，会形成一个全新的私有上下文
	2、无论判断体(function在判断体里）的条件是否成立，带function只会提前声明，不定义
	3、新形成的上下文中对function进行声明+定义，代码执行的时候因为函数不会再执行，但是因为函数在全局下也声明了，当js运行到函数这行代码时，会把之前函数相关的操作映射给全局一份，后面的代码就和全局没有关系了（只要在全局声明过的函数，私有上下文中，执行到相应的函数的代码就要映射一份给全局）
```
	var func=funcion(){}; //->创建匿名函数
	
	var func=function AAA(){};
	AAA();
	//具名化函数不能在外部访问，只能当做函数内部的变量使用
	//好处是：具名化函数可以实现函数的递归调用，避免使用了严格模式下都不支持的argument.callee
```

## 闭包作用域
**概念：我们把函数执行，形成私有上下文，来保存和保护私有变量的机制，称之为“闭包”  =>它是一种机制**

- 函数执行会形成新的私有上下文，这个上下文可能会被释放，也可能不会被释放，无论是否会被释放，它的作用是
	1、保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，而用到的私有变量和其它区域中的变量不会有任何的冲突（防止全局变量污染）
	2、 保存：如果上下文不被销毁，那么存储的私有变量的值也不会被销毁，可以被其下级上下文中调取使用

**市面上一般认为只有形成的私有上下文不被释放，才算是闭包（因为如果一但释放，之前的东西也就不存在了）；还有人认为，只有一下级上下文用到了此上下文中的东西才算闭包；**


- 后期画图的时候 省略执行环境栈的绘制  我们只画执行上下文，默认我们知道，每一个执行上下文出现后，都要进栈执行
- GO 全局对象window    堆内存   浏览器内置的API
- VO(G) 全局变量对象   上下文中的空间   全局上下文中创建的变量
- 基于VAR/FUNCTION在全局上下文中声明的全局变量也会给GO赋值一份（映射机制）
- 但是就LET/CONST等ES6方式在全局上下文中创建的全局变量和GO没有关系

- var/function存在变量提升  但是let/const不会
- 函数的length为形参的个数

### 浏览器的垃圾回收机制（自己内部处理）：

[谷歌等浏览器是“**基于引用查找**“来进行垃圾回收的]

1. 开辟的堆内存，浏览器自己默认会在空闲的时候，查找所有内存的引用，把那些不被引用的内存释放掉
2. 开辟的栈内存（上下文）一般在代码执行完都会出栈释放，如果遇到上下文中的东西被外部占用，则不会释放

[IE等浏览器是“**基于计数器**”机制来进行内存管理的]

1. 创建的内存被引用一次，则计数1，在被引用一次，计数2...  移除引用减去1...  当减为零的时候，浏览器会把内存释放掉
=>真实项目中，某些情况导致计数规则会出现一些问题，造成很多内存不能被释放掉，产生“内存泄漏”；查找引用的方式如果形成相互引用，也会导致“内存泄漏“

- 思考题：总结内存泄露导致的情况
	

### 4.29Day2/3作业

- return的是值  return函数：
  **1、创建一个函数**
  **2、把函数的堆内存地址做为值返回**

- 只有“在除函数体以外大括号中的函数“，在不同的浏览器中表现不一致：低版本是声明+定义   高版本只声明（高版本还会把大括号当做块作用域）

作业2 错题

```js
1.
下面代码输出结果：
let arr=[10.18,0,10,25,23];
arr=arr.map(parseInt);
console.log(arr);

//parseInt(0,1)=>NaN
//=> 没有一进制，radix的范围[2，36]
//=>[10,NaN,2,2,11]

3.
下面代码输出结果：
var a = 4;
function b(x, y, a) {
    console.log(a);
    arguments[2] = 10;
    console.log(a);
}
a = b(1, 2, 3);
console.log(a);

//
/* EC(G)变量提升 
* var a;
	b(x,y,z){} [scope]:EC(G)
* 代码执行
var a=4; //全局的a=4
function b(x,y,a) { 
/*创建私有上下文EC(BLOCK)
    * 初始化作用域<EC(BLOCK),EC(G)>
    * 初始化this--
    * 初始化argument(实参集合，类数组) {0:1,1:2,2:3,length:3}
    * 形参赋值 x=1,y=2,a=3
      ** ==>在JS非严格模式下，函数中初始化ARGUMENTS和形参赋值完成后，浏览器会按照顺序把形参和ARGUMENTS中的每一项建立映射机制（一改都改）
    *   	x -> arguments[0]
    *     y -> arguments[1]
    *     a -> arguments[2]
    * 变量提升--
    * 代码执行
        console.log(a); //=>私有的a=3
        arguments[2]=10; //=>有映射机制，私有a=10
        console.log(a);  //=>私有的a=10
        */
}
a=b(1,2,3); //=>a的值为b函数的返回值，没有返回值 a=undefined
console.log(a);//=>undefined

/* "use strict";
var a = 4;
function b(x, y, a) {
	//严格模式下  x/y/a 和 arguments 是独立的，不会存在映射
	console.log(a); //=>3
	arguments[2] = 10;
	console.log(a); //=>3
}
a = b(1, 2, 3);
console.log(a); //=>undefined */

```
考察：

- ARGUMENT：实参集合(实参的个数按照调用函数时传了几个实参，argument的length就为传进实参的个数，和函数形参个数没有关系)，类数组{0:1,1:2，length：2 }
- 在非严格模式下argument和形参有映射关系，严格模式下没有映射机制
- 函数没有返回值，则被赋值的变量为a=undefined

```
4. 在新版浏览器中，下面代码输出的结果：
{
    function foo(){}
    foo=1;
}
console.log(foo);

/* function在{}，全局下function foo声明 不定义
* function foo
* {}里有function
* 初始化作用域<EC(G) EC(BLOCK)>
* 初始化this，argument
* 形参赋值--
* 变量提升 function foo(){} //定义foo [scope]:EC(BLOCK)
* 代码执行	function foo(){} //代码执行到这一行，因为全局下，foo也声明了一份，所有要返回所有关于foo的操作，全局下的foo赋值为函数创建的地址
    		 		foo=1;//=>私有的foo=1
* 全局的foo=函数
*/
-----------
{
   function foo(){}
   foo=1;
   function foo(){}
}
console.log(foo);
-----------
{
    function foo(){}
    foo=1;
    function foo(){}
    foo=2;
}
console.log(foo);
```

考察：function在大括号里面，全局下只声明没有定义，{}里有function/let/const,会形成新在私有上下文，在私有上下文中变量提升的时候函数声明加定义，代码执行的时候，遇到全局下也声明过的函数代码，需要把函数的地址映射给全局的函数（向前兼容ES3）

![1588210993718](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1588210993718.png)

![1588265378616](C:\Users\陈晓琪\AppData\Roaming\Typora\typora-user-images\1588265378616.png)

```js
5.下面代码输出的结果：
var a=9; 
function fn(){ 
    a=0; 
    return function(b){ 
         return b+a++; 
    } 
}
var f=fn();
console.log(f(5));
console.log(fn()(5)); //=>fn形成的私有上下文执行完暂时不释放，fn返回的地址要立即执行fn()(5)
console.log(f(5));
console.log(a);
```

```js
6.
var test = (function (i) {
    return function () {
        alert(i *= 2);
    }
})(2);
test(5);

//大函数的私有上下文不会出栈释放，因为里面创建的小函数，在全局下，test占用小函数的地址
//test()返回的是里面小函数的地址，小函数没有形参，所以5是传不进去的
//alert的结果是字符串 自动调用toString()
//=>'4' 

```

```js
8.
function fun(n, o) {
    console.log(o);
    return {
        fun: function (m) {
            return fun(m, n);
        }
    };
}
var c = fun(0).fun(1);
c.fun(2);
c.fun(3);
//notebook
```


```

```